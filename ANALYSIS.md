### **Технический Анализ SDK `com.my.tracker`**

#### **Краткий Обзор**

Данный отчет представляет технический анализ SDK `com.my.tracker`. Анализ кода показал, что это многофункциональный SDK для мобильной аналитики и атрибуции. Разработчиком является компания VK, что подтверждается конечной точкой отправки данных `tracker-api.vk-analytics.ru`, указанной в конфигурационных файлах.

Основное назначение SDK сбор детальной информации о пользователе, его устройстве и поведении в приложении. Собранные данные используются для формирования подробного "цифрового профиля", который применяется для аналитики, таргетирования рекламы и атрибуции установок.

---

### **Часть 1: Сбор Персональных и Идентифицирующих Данных (PII)**

SDK предоставляет прямой интерфейс для сбора чувствительной личной информации через класс `MyTrackerParams.java`. Приложение-носитель может передавать следующие категории данных:

*   **Демографические данные:**
    ```java
    // MyTrackerParams.java
    public MyTrackerParams setAge(int v) { ... }
    public MyTrackerParams setGender(int v) { ... }
    ```
    Методы `setAge` и `setGender` позволяют напрямую отправлять возраст и пол пользователя.

*   **Контактные данные:**
    ```java
    // MyTrackerParams.java
    public MyTrackerParams setEmails(String[] arr_s) { ... }
    public MyTrackerParams setPhones(String[] arr_s) { ... }
    ```
    SDK может принимать и отправлять массивы адресов электронной почты и номеров телефонов.

*   **Идентификаторы Социальных Сетей:**
    ```java
    // MyTrackerParams.java
    public MyTrackerParams setVkId(String s) { ... }
    public MyTrackerParams setVkConnectId(String s) { ... }
    public MyTrackerParams setOkId(String s) { ... }
    public MyTrackerParams setIcqId(String s) { ... }
    ```
    Реализован сбор идентификаторов из экосистемы VK Group (VK, Odnoklassniki) и ICQ. Это позволяет связать профиль пользователя в приложении с его профилем в социальных сетях.

*   **Пользовательский ID:**
    ```java
    // MyTrackerParams.java
    public MyTrackerParams setCustomUserId(String s) { ... }
    ```
    Если у пользователя есть внутренний ID в приложении, он также может быть отправлен в трекер для более точной идентификации.

---

### **Часть 2: Создание Устойчивого "Цифрового Отпечатка" Устройства**

Для обеспечения постоянного отслеживания пользователя SDK применяет множество идентификаторов, дублирующих друг друга.

*   **Собственный Уникальный ID (`Instance ID`):**
    В классе `obfuscated/c1.java` SDK генерирует собственный постоянный идентификатор.
    ```java
    // obfuscated/c1.java
    public static String a(Context context0) {
        // ...
        s1 = p0.a(context0).j(); // Попытка чтения из SharedPreferences
        if(TextUtils.isEmpty(s1)) {
            s1 = UUID.randomUUID().toString(); // Генерация нового UUID
            p0.a(context0).k(s1); // Сохранение в SharedPreferences
        }
        // ...
    }
    ```
    При первом запуске создается UUID, который сохраняется в `SharedPreferences`. Этот идентификатор может пережить переустановку приложения при использовании облачного резервного копирования Android, что делает отслеживание крайне устойчивым.

*   **Рекламные и Платформенные Идентификаторы:**
    SDK собирает стандартные отраслевые идентификаторы:
    *   **Google Advertising ID (GAID):** извлекается в `obfuscated/z.java`.
    *   **Huawei Advertising ID (OAID):** извлекается в `obfuscated/e0.java`.
    *   **Firebase App Instance ID:** получается через интеграцию с Firebase SDK в `obfuscated/x.java`.
    *   **App Set ID:** получается из Google Play Services в `obfuscated/d.java` для связи приложений одного разработчика.

**Цель этой стратегии**: создать избыточную систему идентификации. Если пользователь сбросит один из идентификаторов (например, GAID), его можно будет продолжать отслеживать по остальным.

---

### **Часть 3: Профилирование Аппаратного и Программного Обеспечения**

Класс `obfuscated/r.java` отвечает за сбор детальной технической информации об устройстве.

*   **Информация об Устройстве и ОС:**
    ```java
    // obfuscated/r.java
    String s1 = Build.DEVICE;
    String s2 = Build.MANUFACTURER;
    String s3 = Build.MODEL;
    String s4 = Build.VERSION.RELEASE;
    ```
    Собираются данные о производителе, модели, версии Android, системном языке, часовом поясе, разрешении экрана, DPI, а также общем и свободном объеме памяти.

*   **Определение Root-доступа:**
    Внутренний класс `obfuscated/r$a.java` содержит код для проверки наличия root-прав на устройстве.
    ```java
    // obfuscated/r$a.java
    private static boolean a() {
        // ...
        for(int v = 0; v < 10; ++v) {
            if(new File(new String[]{
                "/system/app/Superuser.apk", // Проверка наличия root-приложений
                "/sbin/su",                  // Проверка наличия бинарного файла 'su'
                "/system/bin/su",
                // ... и другие стандартные пути
            }[v]).exists()) {
                return true;
            }
        }
        // ...
    }
    ```
    SDK активно ищет признаки root-доступа. Эта информация используется не только для защиты от мошенничества, но и как дополнительный параметр для уникального "цифрового отпечатка" устройства.

---

### **Часть 4: Отслеживание Приложений и Поведения Пользователя**

*   **Получение Списка Установленных Приложений:**
    Класс `obfuscated/f.java` реализует функционал для получения списка всех сторонних приложений, установленных на устройстве.
    ```java
    // obfuscated/f.java
    private static List b(List list0) {
        // ...
        // (applicationInfo0.flags & 1) == 0  -- флаг, означающий, что приложение не системное
        if((applicationInfo0.flags & 1) == 0) {
            ((ArrayList)list1).add(new a(applicationInfo0.packageName, packageInfo0.firstInstallTime / 1000L));
        }
        // ...
    }
    ```
    Код запрашивает у системы список всех пакетов, отфильтровывает системные и собирает имена пакетов и временные метки установки пользовательских приложений. Эта информация позволяет составить детальный портрет интересов пользователя.

*   **Отслеживание Жизненного Цикла Приложения:**
    Класс `obfuscated/a.java` использует `ActivityLifecycleCallbacks` для автоматического отслеживания сессий.
    ```java
    // obfuscated/a.java
    public void onActivityStarted(Activity activity0) { ... }
    public void onActivityStopped(Activity activity0) { ... }
    ```
    SDK регистрирует фоновый слушатель, который автоматически фиксирует, когда пользователь открывает, сворачивает или закрывает приложение, позволяя измерять длину сессий и частоту использования.

---

### **Часть 5: Хранение и Передача Данных**

*   **Локальное Хранение в Базе Данных:**
    Класс `obfuscated/j0.java` управляет локальной базой данных SQLite для надежного хранения собранных данных.
    ```sql
    CREATE TABLE IF NOT EXISTS table_events(...);
    CREATE TABLE IF NOT EXISTS table_sessions(...);
    ```
    Все события сохраняются локально перед отправкой. Это делает трекер устойчивым к отсутствию сетевого подключения; накопленные данные будут отправлены позже.

*   **Конечная Точка Отправки Данных:**
    В классе конфигурации `obfuscated/z0.java` явно указан адрес сервера.
    ```java
    // obfuscated/z0.java
    private void s() {
        this.d("tracker-api.vk-analytics.ru"); // Установка хоста
    }
    ```
    Все собранные данные централизованно отправляются на `https://tracker-api.vk-analytics.ru/v3/`, что является официальным API трекера VK.

*   **Подготовка Данных к Отправке:**
    Данные проходят два этапа обработки:
    1.  **Сериализация:** В `obfuscated/l0.java` данные упаковываются в собственный бинарный формат.
    2.  **Сжатие:** В `obfuscated/b0.java` и `m0.java` данные сжимаются с помощью GZIP.
    Эти шаги усложняют анализ сетевого трафика.

---

### **Часть 6: Анализ `Protos.java` и Механизм Сбора Данных**

Файл `Protos.java` из пакета `ru.ok.tamtam.nano` не является частью трекера, но критически важен для понимания его потенциала. Он содержит определения **Google Protocol Buffers** для мессенджера **TamTam**.

*   **Структуры Данных:** В файле определены структуры для всех типов данных, передаваемых в мессенджере: аудиосообщения (`Audio`) с полем для транскрипции, геолокация (`Location`) с возможностью передачи трека передвижения, контакты (`Contact`), звонки (`Call`) и т.д.


*   **Механизм Сбора:**
    Сам трекер `my.tracker` работает в пакетном режиме: он накапливает данные в локальной базе и периодически отправляет их. Он не передает данные в реальном времени.

    Однако, приложение-носитель (мессенджер) работает в реальном времени. Наличие `Protos.java` показывает, что трекер может быть настроен на **регистрацию событий в момент совершения любого действия в мессенджере**. Например, событие может быть записано в локальную базу трекера в тот момент, когда пользователь отправляет геолокацию или совершает звонок. Таким образом, *сбор* данных происходит мгновенно, хотя их *отправка* на сервер `my.tracker` отложена.

---

### **Часть 7: Выводы и Анализ Последствий**

#### **Практика Выборочной Обфускации**

Анализ кода выявляет важную деталь: **обфускации подвергнут только пакет, отвечающий за трекинг (`com.my.tracker.obfuscated`)**. Остальной код, например, определения протокола `ru.ok.tamtam.nano`, остается читаемым.

Это стандартная практика для сокрытия шпионских или нежелательных модулей. Разработчики целенаправленно затрудняют анализ именно той части, которая занимается сбором и отправкой данных, зная о ее спорной природе.

#### **Контекст Принудительной Установки**

Факт государственной политики по предустановке приложений с подобным SDK на устройства, продаваемые в стране, выводит ситуацию за рамки коммерческого сбора данных и превращает ее в элемент **инфраструктуры для централизованного сбора данных**.

*   **Масштаб:** Миллионы устройств по умолчанию оснащаются инструментом, который передает исчерпывающую информацию о пользователях и их действиях на серверы, аффилированные с государством.
*   **Отсутствие Выбора и Согласия:** Предустановка на системном уровне лишает пользователя реального выбора. Согласие на сбор такого объема данных становится формальностью, так как приложение уже интегрировано в систему.
*   **Потенциальные Угрозы:** Централизованный доступ к такому массиву данных (геолокация, социальные связи, списки приложений, личные идентификаторы) создает риски, выходящие за рамки таргетированной рекламы. Эти данные могут быть использованы для социального контроля, профилирования граждан и оказания давления.

### **Итоговый Вердикт**

Технический анализ кода подтверждает, что `com.my.tracker` является мощным инструментом для сбора данных, чьи возможности значительно превышают стандартные для аналитических SDK. Он собирает личную информацию, создает устойчивые цифровые отпечатки, отслеживает установленные приложения и поведение пользователя.

Практика выборочной обфускации указывает на намеренное сокрытие этой функциональности. В контексте принудительной государственной предустановки, данный SDK становится элементом масштабной системы по сбору данных о гражданах, что несет в себе серьезные риски для конфиденциальности и гражданских свобод. Таким образом, его можно классифицировать как **шпионское программное обеспечение**.


#### Детали
*   Грамматика у меня страдает, текст был улучшен нейронкой.
*   В большинстве была использована программа JEB Decompiler Pro
*   Анализ был с фокусом на my.tracker, но для полости добавил Protos.java
*   https://github.com/KARENKING112/max-deep-analysis-of-the-messenger
*
   -  android:versionCode="6392"
   -   android:versionName="25.8.1"